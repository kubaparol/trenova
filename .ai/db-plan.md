# Trenova PostgreSQL Database Schema (MVP)

This document outlines the PostgreSQL database schema for the Trenova MVP, based on the PRD and planning session decisions.

## 1. ENUM Types

These custom types ensure data consistency for predefined choices.

```sql
-- Defines the possible training goals for a user
CREATE TYPE public.user_goal AS ENUM (
  'weight_loss',      -- Cel: Redukcja masy ciała
  'muscle_gain',      -- Cel: Budowa masy mięśniowej
  'general_fitness',  -- Cel: Ogólna sprawność
  'strength_increase' -- Cel: Wzrost siły
);

-- Defines the possible experience levels of a user
CREATE TYPE public.experience_level AS ENUM (
  'beginner',         -- Poziom: Początkujący
  'intermediate',     -- Poziom: Średniozaawansowany
  'advanced'          -- Poziom: Zaawansowany
);

-- Defines the types of equipment access a user might have
CREATE TYPE public.equipment_access AS ENUM (
  'none',             -- Dostęp: Brak sprzętu
  'home_basic',       -- Dostęp: Podstawowy sprzęt domowy
  'full_gym'          -- Dostęp: Pełna siłownia
);

-- Defines the gender options for a user profile
CREATE TYPE public.user_gender AS ENUM (
  'male',
  'female',
  'other',
  'prefer_not_to_say'
);
```

## 2. Tables

### 2.1. `profiles`

Stores user profile information and training preferences. Linked one-to-one with `auth.users`.

```sql
CREATE TABLE public.profiles (
  -- Core Fields & Relation
  id uuid NOT NULL PRIMARY KEY REFERENCES auth.users(id) ON DELETE CASCADE, -- Links to auth.users, cascades deletes
  created_at timestamptz NOT NULL DEFAULT now(),
  updated_at timestamptz NOT NULL DEFAULT now(), -- Automatically updated by trigger

  -- User Preferences / Profile Data
  gender public.user_gender, -- User's specified gender
  goal public.user_goal, -- Primary training goal
  experience public.experience_level, -- User's experience level
  days_per_week smallint CHECK (days_per_week >= 1 AND days_per_week <= 7), -- Training days per week (1-7)
  session_duration_minutes smallint CHECK (session_duration_minutes IN (30, 45, 60, 90)), -- Preferred session duration
  equipment public.equipment_access, -- Type of equipment access
  restrictions text[] NOT NULL DEFAULT '{}' -- Array of health restrictions/limitations
);

-- Add comments to the table and columns for clarity
COMMENT ON TABLE public.profiles IS 'Stores user profile information and training preferences, linked to auth.users.';
COMMENT ON COLUMN public.profiles.id IS 'User ID, references auth.users.id.';
COMMENT ON COLUMN public.profiles.updated_at IS 'Timestamp of the last profile update, managed by trigger.';
COMMENT ON COLUMN public.profiles.goal IS 'Primary training goal selected by the user.';
COMMENT ON COLUMN public.profiles.experience IS 'Self-reported training experience level.';
COMMENT ON COLUMN public.profiles.days_per_week IS 'Number of days per week the user plans to train.';
COMMENT ON COLUMN public.profiles.session_duration_minutes IS 'Preferred duration of a single training session in minutes.';
COMMENT ON COLUMN public.profiles.equipment IS 'Level of access to training equipment.';
COMMENT ON COLUMN public.profiles.restrictions IS 'List of any health restrictions or limitations provided by the user.';
```

### 2.2. `training_plans`

Stores the training plans generated for users. Linked many-to-one with `auth.users`.

```sql
CREATE TABLE public.training_plans (
  id uuid NOT NULL PRIMARY KEY DEFAULT gen_random_uuid(), -- Unique identifier for the plan
  user_id uuid NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE, -- User who owns the plan, cascades deletes
  created_at timestamptz NOT NULL DEFAULT now(),

  -- Plan Details
  name text NOT NULL, -- Name of the training plan (e.g., "Plan - Muscle Gain (2024-07-27)")
  plan_details jsonb NOT NULL, -- The structured workout plan (days, exercises, sets, reps, rest) generated by AI
  preferences_snapshot jsonb NOT NULL -- Snapshot of user preferences (from profiles table) at the time of generation
);

-- Add comments to the table and columns for clarity
COMMENT ON TABLE public.training_plans IS 'Stores AI-generated training plans for users.';
COMMENT ON COLUMN public.training_plans.user_id IS 'The user associated with this training plan.';
COMMENT ON COLUMN public.training_plans.name IS 'User-editable name for the training plan.';
COMMENT ON COLUMN public.training_plans.plan_details IS 'JSONB structure containing the detailed workout schedule and exercises.';
COMMENT ON COLUMN public.training_plans.preferences_snapshot IS 'JSONB snapshot of key user preferences used to generate this specific plan.';

```

## 3. Relationships

- **`profiles` to `auth.users`**: One-to-One. Established via `profiles.id` being both `PRIMARY KEY` and `FOREIGN KEY REFERENCES auth.users(id) ON DELETE CASCADE`.
- **`training_plans` to `auth.users`**: Many-to-One. Established via `training_plans.user_id uuid NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE`.

The `ON DELETE CASCADE` ensures that when a user is deleted from `auth.users`, their corresponding `profiles` record and all their `training_plans` records are automatically deleted, complying with data removal requirements.

## 4. Indexes

In addition to the default Primary Key indexes and potential Foreign Key indexes created by PostgreSQL/Supabase:

```sql
-- Optimizes fetching the most recent plans for a specific user
CREATE INDEX idx_training_plans_user_created_at
ON public.training_plans (user_id, created_at DESC);
```

## 5. Row Level Security (RLS)

RLS is enabled to ensure users can only access and modify their own data.

```sql
-- Enable RLS for profiles and training_plans tables
ALTER TABLE public.profiles ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.training_plans ENABLE ROW LEVEL SECURITY;

-- Grant all actions to the anon and authenticated roles initially (policies will restrict)
-- Supabase typically handles initial grants, but ensuring they exist.
-- Adjust roles as necessary for your Supabase setup if not using standard 'anon' and 'authenticated'.
GRANT ALL ON TABLE public.profiles TO anon, authenticated;
GRANT ALL ON TABLE public.training_plans TO anon, authenticated;


-- Policies for 'profiles' table
DROP POLICY IF EXISTS "Allow individual user access to own profile" ON public.profiles;
CREATE POLICY "Allow individual user access to own profile"
ON public.profiles
FOR SELECT
USING (auth.uid() = id);

DROP POLICY IF EXISTS "Allow individual user update access to own profile" ON public.profiles;
CREATE POLICY "Allow individual user update access to own profile"
ON public.profiles
FOR UPDATE
USING (auth.uid() = id)
WITH CHECK (auth.uid() = id); -- Redundant check for clarity/safety


-- Policies for 'training_plans' table
DROP POLICY IF EXISTS "Allow individual user access to own plans" ON public.training_plans;
CREATE POLICY "Allow individual user access to own plans"
ON public.training_plans
FOR SELECT
USING (auth.uid() = user_id);

DROP POLICY IF EXISTS "Allow individual user insert access for own plans" ON public.training_plans;
CREATE POLICY "Allow individual user insert access for own plans"
ON public.training_plans
FOR INSERT
WITH CHECK (auth.uid() = user_id);

DROP POLICY IF EXISTS "Allow individual user update access to own plans" ON public.training_plans;
CREATE POLICY "Allow individual user update access to own plans"
ON public.training_plans
FOR UPDATE
USING (auth.uid() = user_id)
WITH CHECK (auth.uid() = user_id); -- Ensure users can only update their own plans

DROP POLICY IF EXISTS "Allow individual user delete access to own plans" ON public.training_plans;
CREATE POLICY "Allow individual user delete access to own plans"
ON public.training_plans
FOR DELETE
USING (auth.uid() = user_id);
```

## 6. Triggers and Functions

These automate certain database operations.

### 6.1. `handle_new_user`

Creates a corresponding `profiles` record when a new user signs up (inserted into `auth.users`).

```sql
-- Function to create a profile for a new user
CREATE OR REPLACE FUNCTION public.handle_new_user()
RETURNS TRIGGER
LANGUAGE plpgsql
SECURITY DEFINER -- Necessary to interact with 'public.profiles' from 'auth.users' trigger
SET search_path = ''
AS $$
BEGIN
  INSERT INTO public.profiles (id)
  VALUES (new.id);
  RETURN new;
END;
$$;

-- Trigger to call the function after a user is created in auth.users
DROP TRIGGER IF EXISTS on_auth_user_created ON auth.users;
CREATE TRIGGER on_auth_user_created
  AFTER INSERT ON auth.users
  FOR EACH ROW EXECUTE FUNCTION public.handle_new_user();

```

### 6.2. `handle_updated_at`

Updates the `updated_at` timestamp on the `profiles` table whenever a record is modified.

```sql
-- Generic function to update 'updated_at' timestamp
CREATE OR REPLACE FUNCTION public.handle_updated_at()
RETURNS TRIGGER
LANGUAGE plpgsql
AS $$
BEGIN
  new.updated_at = now();
  RETURN new;
END;
$$;

-- Trigger to update profiles.updated_at timestamp on modification
DROP TRIGGER IF EXISTS on_profile_updated ON public.profiles;
CREATE TRIGGER on_profile_updated
  BEFORE UPDATE ON public.profiles
  FOR EACH ROW EXECUTE FUNCTION public.handle_updated_at();

```

## 7. Additional Considerations

- **Data Validation:** Input validation (e.g., for `restrictions` array content, `plan_details` structure) should primarily occur at the application/API layer before insertion. Database constraints (`CHECK`) provide a baseline integrity check.
- **`plan_details` JSONB Structure:** While the exact structure isn't defined here, it's expected to be consistent (e.g., `{"day1": [{"exercise": "Push-up", "sets": 3, "reps": 10, "rest_seconds": 60}, ...], "day2": ...}`). The application layer is responsible for generating and parsing this structure.
- **`preferences_snapshot` JSONB Structure:** This should contain key-value pairs mirroring the relevant fields from the `profiles` table at the time the plan was generated (e.g., `{"goal": "muscle_gain", "experience": "intermediate", "days_per_week": 4, ...}`).
- **Admin Access:** For MVP, administrative access (e.g., for support) is intended to be handled outside the application's RLS, likely directly via Supabase Studio or specific admin roles/policies if implemented later.
- **Default Plan Name:** The application backend is responsible for generating a sensible default name for `training_plans.name` upon creation, as decided in the planning session (e.g., "Plan - {goal} ({created_at::date})").
